
[깃 공식 홈페이지](https://git-scm.com/)



# 깃 시작하기 

📌git 명령어 --help // 명령어 매뉴얼 호출
### init 

```
git init // 버전 관리를 시작하겠다.
git clone // 원격저장소에 있는 파일들을 로컬저장소에 다운로드 받음.
```
### 초기 설정 
- 시스템 전체가 아닌 해당 프로젝트에만 적용하고 싶다면 —global 을 빼주면 된다

```
git config --global user.name 유저명  //유저이름 설정 
git config --global user.email 이메일 //이메일 설정
git config --global core.editor vim // 코어 에디터를 vim으로 설정 
git config --global core.autocrlf true // 커밋할때에는 *CRLF를 LF로 변환, git코드를 clone할때에는  LF를 CRLF로 변환.

```
 *유닉스 시스템에서는 한 줄의 끝이 LF(Line Feed)로 이루어지는 반면, 윈도우에서는 줄 하나가 CR(Carriage Return)와 LF(Line Feed)

### add
: 원하는 파일만 선택적으로 커밋할 수 있도록 해줌. 해당 파일을커밋대기상태로 만들어줌.

 
``` 
git add 파일명 // commit 목록에 추가하기
```

### commit

```
git commit //커밋
git commit -m "메시지" //커밋메시지까지 작성
git commit -a/git commit --all //삭제하거나 변경한 파일을 자동으로 stage 에 올리고 커밋 (add필요X)

 ```
 🔹속성의 나열
 :- 뒤에 덧붙이고자 하는 속성을 나열해줌으로써 그 두개의 속성을 모두 지닌 명령어를 만들수 있다.
 
 ex) `git commit -am` : 모든변경된파일 커밋(a) + 메시지 작성(m)
 ->단, 이때 한번도 버전관리(add) 되지 않은 파일은 stage에 올려지지 X
 
### 커밋내역확인
- +++:추가된파일 ---:삭제된 파일
- 각 commit(버전)마다 고유의 아이디 존재. ex) `0765226a2c62acbbe831d07247ee84955a39f288`
- stage area : 커밋 대기상태에 있는 파일들이 존재하는 곳


```
 git log // history확인 
 git log -p //이전커밋과의 차이점을 보여줌  
 git diff // 바로 이전 커밋과 비교했을때 바뀐점(차이점) 출력. 커밋하기전 마지막 확인 
 git diff 커밋아이디1..커밋아이디2 //두 커밋상의 차이점을 보여줌
 git log 커밋아이디 // 그 커밋 이전 내역의 history만 출력함

``` 

## 과거로 돌아가기

[🔍reset,revert사용법](https://www.lainyzine.com/ko/article/git-reset-and-git-revert-and-git-commit-amend/)
- reset : 현재 작업 위치인 HEAD의 포인터를 특정위치로 바꿈으로서 상태를 강제변경한다. -> 협업시에는 절대 ❌❌
- revert : 특정 커밋의 내용을 되돌리는 커밋을 한다. 
- amend : 스테이지에 추가된 내용을 반영해주는 동시에 커밋메시지도 변경. 변경할내용이 없을대도 커밋메시지를 변경하고 싶을때 사용.
[🔍reset과 revert의 차이](https://www.lainyzine.com/ko/article/git-revert-reverting-commit-in-git-repository/)

```
git reset 커밋아이디 --hard    //  커밋아이디를 최신버전으로 한다. (해당 커밋까지 포함)
git reset --hard HEAD^        // 바로 직전 커밋으로 되돌린다. 
git revert 커밋아이디          // 커밋아이디를 커밋으로 하는 새로운 커밋을 생성한다.
git reset --hard HEAD           //HEAD가 가리키는 커밋으로 돌아간다. 
git reset -- hard             // 최신 커밋으로 돌아간다.
```
--hard 옵션의 역할? 
:현재 HEAD에서 추가된 변경사항들을 모두 되돌려준다. 
그러나, Git저장소에서 관리 하지 않는 파일들을 추가한 경우, 이 파일들은 reset이후에도 그대로 유지된다. (커밋과 비교했을때 다른점이 있는 것만 원래대로 돌려놓은것이므로! -> 이 파일들 까지 삭제하고자하는경우 git clean -n 을 이용하면 된다.) 


## Branch 
- 작업을 분할해서 진행
- HEAD -> 현재 체크아웃된 브랜치를 가리킴
```
git branch                                     // 브랜치 목록 확인. 현재브랜치에는 *표시
git branch 브랜치명                            // 현재 *하는 브랜치에서 브랜치 생성
git checkout 브랜치명                          // 해당 브랜치로 *(HEAD)가 이동. 
git checkout -b 브랜치명                       // 브랜치 생성 + HEAD 이동 을 동시에!
git log --branches --decorate                    // 전체브랜치들이 어떤 커밋에 위치해있는지 알려줌.
git log --branches --decorate --graph            // *과 꺾은 가지 형태로 어떤 커밋을 지나쳐 왔는지까지 시각적으로 알려줌
git log --branches --decorate --graph --oneline // 간략하게 보여줌
git branch -d 브랜치명 //브랜치 삭제
```

## 비교하기
```
git log master..비교할브랜치    // master브랜치와 비교할 브랜치간의 차이(master에는 없고 exp에는 있는것)를 보여줌. 
git log -p master..비교할브랜치 // 각각의 버전별로 소스코드에 어떤차이가 있는지까지 알려줌.
git diff 브랜치1 브랜치2         // 브랜치1과 비교했을때 브랜치2가 가지는 특징.
```
diff와 log비교의 차이?
각각의 브랜치들의 `현재` 상태만을 비교
stree 
## 깃 에러 
- CRLF : https://blog.jaeyoon.io/2018/01/git-crlf.html


# merge
특정브랜치를 master로 가져오기 위해서는 
1. 우선 master로 체크아웃
2. git merge `브랜치명`
```
git 

```

📌`Fast-forward`와  `Merge made by the 'recursive' strategy.`
:  현재 브랜치가 가리키는 커밋이 Merge 할 브랜치의 조상이 아닐때에는 Git은 `Fast-forward`로 Merge 하지 않는다.
즉, merge할 커밋이 현재 브랜치가 가리키는 커밋과 일렬을 이룬다면 단순히 `Fast-forward` 방식으로 현재 브랜치가 그 커밋을 가리키도록 빨리감기 한다. 그러나 갈림길로 갈라져 있는 경우에는 Git은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3-way Merge를 한다.

📌그래프 해석하기
![20211014194338](https://user-images.githubusercontent.com/86418674/137302897-304dae03-99be-4d32-9c5d-86f623d3e008.png)
1. exp는 커밋 2로부터 branch되었다.
2. exp 에서 추가적인 커밋이 두번 진행되었다. (3,f2추가)
3. exp를 master브랜치로 merge하였다. 최신 상태의 master는 exp가 가지는 두개의 커밋을 모두 가지는 상태가 된다. 
4. * 지점은 커밋이 일어난 곳을 표시한다.


## stash 
: 브랜치의 작업이 다 끝나지 않았는데 master(or 일반브랜치)로 checkout해야하는 경우에 현재 브랜치에서 커밋되지 않고 변경된 내역(작업했던것)을 감춰두는것
-> 커밋을 안하고 checkout 하면 변경된 파일이 master브랜치에까지 영향을 줌!! (다른 브랜치에서 변경한건데 master 브랜치에서 변경이 있었더 것처럼 보임) stauts
- stash는 tracked 되고있는 파일에만 적용.

```
git stash         // 작업했던 내용을 숨겨놓음
git stash apply   // 가장 최신 stash [0]을 가져옴
git stash list     // stash된 목록 보여줌. -> 명시적으로 삭제하지 않는이상 항상 살아있음.
git stash drop      // 가장 최신 stash를 삭제함. 
git stash pop       // apply + drop
```

